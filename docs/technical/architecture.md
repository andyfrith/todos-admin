# Modular Architecture Documentation

This document outlines the modular (layered) or "composable" architecture used in the application. The architecture follows a clean separation of concerns with distinct organization for data access, business logic, and server-side operations.

## Architecture Overview

The codebase implements a **modular architecture** that promotes:

- **Separation of concerns** - Each module (layer) has a specific responsibility
- **Testability** - Business logic can be tested independently
- **Maintainability** - Changes in one layer don't affect others
- **Reusability** - Server logic and hooks can be reused across routes and components

### Key technologies

| Area | Technology |
|------|------------|
| Framework | TanStack Start (React + Vite + Nitro) |
| Routing | TanStack Router (file-based) |
| Data & cache | TanStack Query (React Query) |
| Database | PostgreSQL + Drizzle ORM |
| Validation & types | Zod + TypeScript |
| Styling | Tailwind CSS, shadcn-style components |
| Notifications | Sonner (toasts) |

### Directory layout

```
src/
├── router.tsx          # Router Setup
├── routeTree.gen.ts    # Generated route tree (do not edit)
├── styles.css          # Styling Configuration
├── components/         # UI Components
├── data/               # Data Files
├── db/                 # Database and Drizzle Configuration
├── hooks/              # Reusable React Hooks
├── integrations/       # External Tool Integrations (e.g. TanStack Query)
├── lib/                # Utils and Reusable Library Components
├── queries/            # Reusable Tan Stack Query Options
├── routes/             # Tan Stack Routes
├── types/              # Type Definitions
├── server/             # TanStack Start server functions
└── db/                 # Database schema and connection (Drizzle)
```

## Router (`src/router.tsx`)

Central router setup using **TanStack Router**. The router is created via `getRouter()`, which:

- Imports the generated `routeTree` from `routeTree.gen.ts`
- Injects **TanStack Query** context (query client) so routes and components can use the same client
- Enables **SSR query integration** so server-rendered data is hydrated on the client
- Sets `defaultPreload: 'intent'` for faster navigation (preloads on link hover/focus)

The router is used by the TanStack Start runtime; do not call `getRouter()` from application code.

## Route Tree (`src/routeTree.gen.ts`)

**Auto-generated** by the TanStack Router plugin (from `vite.config`). Do not edit this file.

- Reflects the file-based routes under `src/routes/`
- Exports `routeTree` and TypeScript types for type-safe navigation (`FileRoutesByPath`, `FileRoutesByTo`, etc.)
- Regenerated when route files are added, removed, or renamed

## Styles (`src/styles.css`)

Global styling entry point:

- **Tailwind CSS** via `@import 'tailwindcss'`
- **tw-animate-css** for animations
- **CSS custom properties** for theming (e.g. `--background`, `--foreground`, `--primary`) with light/dark support via `@custom-variant dark`
- Base styles for `body` and `code`

The root route links this file so it applies to the whole app.

## Types and validation

Application and validation types live in **`src/lib/schema.ts`** (not a separate `types/` folder):

- **Zod schemas** for runtime validation (e.g. `TodoSchema`, `TodoTypeSchema`)
- **Inferred TypeScript types** (e.g. `Todo`, `TodoType`) used by forms, server functions, and components

Database table types come from **Drizzle** in `src/db/schema.ts`; the app uses `Todo` from `lib/schema` for API and UI consistency.

## Components (`src/components`)

UI is split into:

- **Feature components** – e.g. `components/todos/` (Todos, Todo, AddTodo, EditTodo, TodoForm, TodoShadcnForm, FeatureInfo)
- **Shared UI** – `components/ui/` (shadcn-style: button, input, label, checkbox, select, field, separator, sonner toaster)
- **Layout** – `Header.tsx`
- **Storybook** – `components/storybook/` for isolated component development

Components use **hooks** and **server functions** (via hooks) for data; they do not call the database or server functions directly except through hooks.

## Data (`src/data`)

Holds static or demo data and optional server functions for that data:

- **`demo.punk-songs.ts`** – demo song list and a `getPunkSongs` server function (example of a server function colocated with data)

For domain data (e.g. todos), server functions and database access live under **`src/server/fn/`** and **`src/db/`**.

## Hooks (`src/hooks`)

Reusable React hooks that wrap **TanStack Query** and **server functions**:

- **`useTodos.ts`** – `useTodos()` (query), `useCreateTodo()`, `useUpdateTodo()`, `useDeleteTodo()` (mutations)
- Hooks call server functions (e.g. `getTodos`, `createTodo`) and handle cache invalidation (`queryKey: ['todos']`) and toasts (e.g. via **Sonner**)

This keeps components free of fetch/cache logic and centralizes loading/error/success behavior.

## Integrations (`src/integrations`)

Third-party integrations:

- **`tanstack-query/`** – `root-provider.tsx` (creates and provides `QueryClient`, used by the router context), `devtools.tsx` (React Query devtools panel)

Used by the root route and router for global Query Client and devtools.

## Lib (`src/lib`)

Shared utilities and app-level schemas:

- **`utils.ts`** – `cn()` for merging Tailwind classes (clsx + tailwind-merge)
- **`schema.ts`** – Zod schemas and inferred types for Todo (see **Types and validation**)

## Queries (`src/queries`)

**TanStack Query** options factories for consistent keys and fetch logic:

- **`todos.tsx`** – `todosQueryOptions()` (queryKey `['todos']`, uses `getTodos`), `todosDeleteMutationOptions(todoId)` for delete mutations

Used by hooks (e.g. `useTodos` spreads `todosQueryOptions()`) so query keys and `queryFn`s stay consistent across the app.

## Routes (`src/routes`)

**TanStack Router** file-based routes:

- **`__root.tsx`** – Root layout: HTML shell, HeadContent, Scripts, Header, Toaster, TanStack Router/Query devtools; injects router context (e.g. `queryClient`)
- **`index.tsx`** – `/`
- **`todos/route.tsx`** – Layout for `/todos` (Outlet for child routes)
- **`todos/index.tsx`** – `/todos` list (renders `Todos`)
- **`todos/add.tsx`** – `/todos/add` (renders `AddTodo`)
- **`todos/$id/edit.tsx`** – `/todos/:id/edit` (renders `EditTodo`)

Routes use `createFileRoute` and render feature components that rely on hooks for data.

## Server Functions (`src/server/fn/`)

Uses **TanStack Start** server functions to expose business logic as API endpoints with middleware support.

### Structure:

```
src/server/fn/
└── todos.ts          # Todo CRUD server functions (getTodos, createTodo, updateTodo, deleteTodo)
```

Other domain modules (e.g. posts) would follow the same pattern: one file per domain with GET/POST handlers.

### Example: `src/server/fn/todos.ts`

```typescript
import { createServerFn } from '@tanstack/react-start';
import { desc, eq } from 'drizzle-orm';
import type { Todo } from '@/lib/schema';
import { db } from '@/db/index';
import { todos } from '@/db/schema';

export const getTodos = createServerFn({ method: 'GET' }).handler(async () => {
  return (await db.query.todos.findMany({
    orderBy: [desc(todos.createdAt)],
  })) as Array<Todo>;
});

export const createTodo = createServerFn({ method: 'POST' })
  .inputValidator((data: { title: string }) => data)
  .handler(async ({ data }) => {
    await db.insert(todos).values({ title: data.title });
    return { success: true };
  });

export const updateTodo = createServerFn({ method: 'POST' })
  .inputValidator((data: { id: number; title: string; todoType?: string; completed?: boolean }) => data)
  .handler(async ({ data }) => {
    await db.update(todos).set({ title: data.title, updatedAt: new Date() }).where(eq(todos.id, data.id));
    return { success: true };
  });

export const deleteTodo = createServerFn({ method: 'POST' })
  .inputValidator((data: { id: number }) => data)
  .handler(async ({ data }) => {
    await db.delete(todos).where(eq(todos.id, data.id));
    return { success: true };
  });
```

### Key Characteristics:

- **Middleware support** - Authentication, validation, rate limiting
- **Type safety** - Full TypeScript support
- **HTTP method specification** - GET, POST, PUT, DELETE
- **Context injection** - User authentication, request data
- **Direct data access** - Can call data access layer directly for simple operations (e.g. Drizzle `db` in handlers)

## Database (`src/db/`)

Persistence and schema are handled by **Drizzle ORM** and **PostgreSQL**:

- **`schema.ts`** – Table definitions (e.g. `todos`: id, title, todoType, completed, createdAt, updatedAt). Uses `drizzle-orm/pg-core` (pgTable, integer, text, boolean, timestamp).
- **`index.ts`** – Creates the Drizzle client with `drizzle(getDatabaseUrl(), { schema })`. `getDatabaseUrl()` reads `DATABASE_URL` or builds from `DB_USER`, `DB_PASSWORD`, `DB_HOST`, `DB_PORT`, `DB_NAME` (aligned with `drizzle.config.ts`).

Migrations are generated and applied via **Drizzle Kit** (`pnpm db:generate`, `pnpm db:migrate`, `pnpm db:push`). Schema is the single source of truth for the DB; app types for API/UI live in `lib/schema.ts`.

**Environment:** Database URL is read from `DATABASE_URL` or from `DB_USER`, `DB_PASSWORD`, `DB_HOST`, `DB_PORT`, `DB_NAME` (see `src/db/index.ts` and `drizzle.config.ts`). Use `.env` or `.env.local` for local development.

## Presentation layer

The top layer handles routing, UI, and user interactions.

### Routes and pages

- **TanStack Router** file-based routes under `src/routes/` define URLs and layout (see **Routes** above).
- There are no separate “API route” files; **server functions** are invoked from the client (via hooks) and run on the server. TanStack Start exposes them over HTTP internally.

### React components

- **Route components** (e.g. in `todos/index.tsx`, `todos/add.tsx`) render feature components (`Todos`, `AddTodo`, `EditTodo`).
- **Feature components** get data and mutations from **hooks** (e.g. `useTodos`, `useCreateTodo`), which in turn call server functions and manage TanStack Query cache and toasts.
- **Shared UI** (`components/ui/`) is used for consistent forms and controls (e.g. shadcn-style components with `lib/utils` `cn()`).

## Data flow

### Typical request flow

1. **User action** (e.g. submit form, click delete) in a component.
2. **Hook** (e.g. `useCreateTodo`) runs a mutation that calls a **server function** (e.g. `createTodo`).
3. **Server function** runs on the server: validates input (optional `inputValidator`), then uses **Drizzle** to read/write **PostgreSQL**.
4. **Server function** returns; hook invalidates relevant **TanStack Query** keys and optionally shows a toast.
5. **Queries** (e.g. `useTodos`) refetch or update from cache, and the UI re-renders.

### Example: creating a todo

1. User visits `/todos/add` and submits the form in `AddTodo`.
2. `TodoForm` / `TodoShadcnForm` calls `onFormSubmit(data)` with the form payload.
3. `AddTodo` passes `data.title` to `createTodoMutation.mutate(data.title)` from `useCreateTodo()`.
4. `useCreateTodo`’s `mutationFn` calls `createTodo({ data: { title } })`, which is a TanStack Start server function.
5. On the server, `createTodo`’s handler validates `data` and runs `db.insert(todos).values({ title: data.title })`.
6. Handler returns `{ success: true }`; the mutation’s `onSuccess` runs: `queryClient.invalidateQueries({ queryKey: ['todos'] })` and a success toast is shown.
7. `useTodos()` refetches; the list component re-renders with the new todo.

## Benefits of This Architecture

### 1. **Separation of Concerns**

- Database access is confined to server functions (and optionally shared in `db/`)
- UI depends on hooks and query options, not on server or DB directly
- Server functions define HTTP method and validation; handlers contain data and business logic

### 2. **Testability**

- Server function handlers can be unit tested with a mocked `db`
- Hooks can be tested with mocked server functions (e.g. Vitest + React Testing Library)
- Query options and pure utils in `lib/` are easy to test in isolation
- **E2E tests** (Playwright) cover route rendering and navigation; see `docs/e2e-testing.md`

### 3. **Maintainability**

- Changes in one layer don't cascade to others
- Clear interfaces between layers
- Easy to add new features or modify existing ones

### 4. **Reusability**

- Server functions can be called from any client (web, future mobile or API consumers)
- Hooks and query options centralize cache and UI behavior for reuse across components
- Shared types in `lib/schema` keep forms, server, and UI in sync

### 5. **Type Safety**

- Full TypeScript support across all layers
- Shared types ensure consistency
- Compile-time error checking

## Best Practices

### 1. **Layer Dependencies**

- **Presentation** (routes, components) → **Hooks** → **Server functions** → **Database**
- Server functions and `db` must not import from routes or components
- Hooks and query options depend on server functions; components depend on hooks (or query options)

### 2. **Error Handling**

- Handle infrastructure errors (e.g. DB, network) in server function handlers
- Use mutation `onError` in hooks to show toasts or fallback UI
- Provide meaningful error messages to users and log details server-side where appropriate

### 3. **Type Definitions**

- Keep shared domain types and Zod schemas in `src/lib/schema.ts`
- Use Drizzle schema in `src/db/schema.ts` for DB; align API/UI types with `lib/schema` where possible
- Use specific types for server function inputs/outputs and avoid `any`

### 4. **Naming**

- Server functions: `verbNoun` (e.g. `getTodos`, `createTodo`, `updateTodo`, `deleteTodo`)
- Hooks: `useNoun` for queries, `useVerbNoun` for mutations (e.g. `useTodos`, `useCreateTodo`)
- Query options: `nounQueryOptions`, `nounVerbMutationOptions` (e.g. `todosQueryOptions`)

### 5. **Middleware and validation**

- Use server function `inputValidator` for request payload validation
- Keep business and data access logic inside the handler; use middleware for cross-cutting concerns (auth, logging) when added

## Conclusion

This modular (layered) architecture provides a solid foundation for building maintainable, testable, and scalable applications. The clear separation of concerns makes it easy to understand the codebase structure and modify individual components without affecting others.

### Related documentation

- **E2E testing** – `docs/e2e-testing.md` for Playwright setup, commands, and test structure.
- **Forms (React Hook Form + shadcn)** – `docs/ux/forms-react-hook-form-shadcn.md` for form patterns and validation used in todo create/edit.
